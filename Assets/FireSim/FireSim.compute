

#pragma kernel Inject
#pragma kernel Advect
// #pragma kernel CurlNoise
#pragma kernel FillTest

// Grid
int _GridX;
int _GridY;
int _GridZ;
float _DeltaTime;

// Injection
float3 _InjectionPoint;
float _InjectionRadius;
float _InjectionStrength;
float _InjectionVelocity;

// Textures
RWTexture3D<float4> VelocityPrev;
RWTexture3D<float4> VelocityNext;
RWTexture3D<float>  DensityPrev;
RWTexture3D<float>  DensityNext;


[numthreads(8, 8, 8)]
void Inject(uint3 id : SV_DispatchThreadID)
{
    // If out of bounds
    if (id.x >= (uint)_GridX || id.y >= (uint)_GridY || id.z >= (uint)_GridZ)
        return;
    
    // Calculate distance from injection point
    float3 pos = float3(id.xyz);
    float3 injectionPos = float3(_GridX * 0.5, 2.0, _GridZ * 0.5);
    float dist = length(pos - injectionPos);
    
    // Copy previous values
    float density = DensityPrev[id.xyz];
    float4 velocity = VelocityPrev[id.xyz];
    
    // Add density and upward velocity near injection point
    if (dist < _InjectionRadius)
    {
        float strength = 1.0 - (dist / _InjectionRadius); // Falloff
        density += strength * _InjectionStrength;
        velocity.y += strength * 5.0; // Upward push
    }
    
    // results
    DensityNext[id.xyz] = density;
    VelocityNext[id.xyz] = velocity;
}

float SampleDensity(float3 pos)
{
    // Clamp to grid bounds
    pos = clamp(pos, float3(0, 0, 0), float3(_GridX - 1, _GridY - 1, _GridZ - 1));
    
    // Get integer and fractional parts
    int3 i0 = int3(floor(pos));
    int3 i1 = min(i0 + 1, int3(_GridX - 1, _GridY - 1, _GridZ - 1));
    float3 f = frac(pos);
    
    // Sample 8 corners
    float c000 = DensityPrev[int3(i0.x, i0.y, i0.z)];
    float c100 = DensityPrev[int3(i1.x, i0.y, i0.z)];
    float c010 = DensityPrev[int3(i0.x, i1.y, i0.z)];
    float c110 = DensityPrev[int3(i1.x, i1.y, i0.z)];
    float c001 = DensityPrev[int3(i0.x, i0.y, i1.z)];
    float c101 = DensityPrev[int3(i1.x, i0.y, i1.z)];
    float c011 = DensityPrev[int3(i0.x, i1.y, i1.z)];
    float c111 = DensityPrev[int3(i1.x, i1.y, i1.z)];
    
    // Trilinear interpolation
    float c00 = lerp(c000, c100, f.x);
    float c10 = lerp(c010, c110, f.x);
    float c01 = lerp(c001, c101, f.x);
    float c11 = lerp(c011, c111, f.x);
    
    float c0 = lerp(c00, c10, f.y);
    float c1 = lerp(c01, c11, f.y);
    
    return lerp(c0, c1, f.z);
}

// https://en.wikipedia.org/wiki/Trilinear_interpolation
float4 SampleVelocity(float3 pos)
{
    // Similar to SampleDensity but for float4
    pos = clamp(pos, float3(0, 0, 0), float3(_GridX - 1, _GridY - 1, _GridZ - 1));
    
    int3 i0 = int3(floor(pos));
    int3 i1 = min(i0 + 1, int3(_GridX - 1, _GridY - 1, _GridZ - 1));
    float3 f = frac(pos);
    
    float4 c000 = VelocityPrev[int3(i0.x, i0.y, i0.z)];
    float4 c100 = VelocityPrev[int3(i1.x, i0.y, i0.z)];
    float4 c010 = VelocityPrev[int3(i0.x, i1.y, i0.z)];
    float4 c110 = VelocityPrev[int3(i1.x, i1.y, i0.z)];
    float4 c001 = VelocityPrev[int3(i0.x, i0.y, i1.z)];
    float4 c101 = VelocityPrev[int3(i1.x, i0.y, i1.z)];
    float4 c011 = VelocityPrev[int3(i0.x, i1.y, i1.z)];
    float4 c111 = VelocityPrev[int3(i1.x, i1.y, i1.z)];
    
    float4 c00 = lerp(c000, c100, f.x);
    float4 c10 = lerp(c010, c110, f.x);
    float4 c01 = lerp(c001, c101, f.x);
    float4 c11 = lerp(c011, c111, f.x);
    
    float4 c0 = lerp(c00, c10, f.y);
    float4 c1 = lerp(c01, c11, f.y);
    
    return lerp(c0, c1, f.z);
}

[numthreads(8,8,8)]
void Advect(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= (uint)_GridX || id.y >= (uint)_GridY || id.z >= (uint)_GridZ)
        return;
    
    // Semi-Lagrangian advection (Stam 1999)
    float3 pos = float3(id.xyz);
    float3 vel = VelocityPrev[id.xyz].xyz;
    
    // Trace particle backward in time
    float3 prevPos = pos - vel * _DeltaTime;
    
    // Sample previous values at traced position
    float newDensity = SampleDensity(prevPos);
    float4 newVelocity = SampleVelocity(prevPos);
    
    // Write advected values
    DensityNext[id.xyz] = newDensity;
    VelocityNext[id.xyz] = newVelocity;
}

// Test
[numthreads(8,8,8)]
void FillTest(uint3 id : SV_DispatchThreadID)
{
    // Normalize coordinates 0..1
    float nx = id.x / (float)(_GridX - 1);
    float ny = id.y / (float)(_GridY - 1);
    float nz = id.z / (float)(_GridZ - 1);

    // Create a gradient cube to test
    DensityNext[id.xyz] = nx * ny * nz;
}
