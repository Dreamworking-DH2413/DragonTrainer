

#pragma kernel Inject
#pragma kernel Advect
// #pragma kernel CurlNoise
#pragma kernel FillTest

// Grid
int _GridX;
int _GridY;
int _GridZ;
float _DeltaTime;

// Injection
float3 _InjectionPoint;
float _InjectionRadius;
float _InjectionStrength;
float _InjectionVelocity;

// Textures
RWTexture3D<float4> VelocityPrev;
RWTexture3D<float4> VelocityNext;
RWTexture3D<float>  DensityPrev;
RWTexture3D<float>  DensityNext;


[numthreads(8, 8, 8)]
void Inject(uint3 id : SV_DispatchThreadID)
{
    // If out of bounds
    if (id.x >= (uint)_GridX || id.y >= (uint)_GridY || id.z >= (uint)_GridZ)
        return;
    
    // Calculate distance from injection point
    float3 pos = float3(id.xyz);
    float3 injectionPos = float3(_GridX * 0.5, 2.0, _GridZ * 0.5);
    float dist = length(pos - injectionPos);
    
    // Copy previous values
    float density = DensityPrev[id.xyz];
    float4 velocity = VelocityPrev[id.xyz];
    
    // Add density and upward velocity near injection point
    if (dist < _InjectionRadius)
    {
        float strength = 1.0 - (dist / _InjectionRadius); // Falloff
        density += strength * _InjectionStrength;
        velocity.y += strength * 5.0; // Upward push
    }
    
    // results
    DensityNext[id.xyz] = density;
    VelocityNext[id.xyz] = velocity;
}

float SampleDensity(float3 pos)
{
    // Clamp to grid bounds
    pos = clamp(pos, float3(0, 0, 0), float3(_GridX - 1, _GridY - 1, _GridZ - 1));
    
    // Get integer and fractional parts
    int3 i0 = int3(floor(pos));
    int3 i1 = min(i0 + 1, int3(_GridX - 1, _GridY - 1, _GridZ - 1));
    float3 f = frac(pos);
    
    // Sample 8 corners
    float c000 = DensityPrev[int3(i0.x, i0.y, i0.z)];
    float c100 = DensityPrev[int3(i1.x, i0.y, i0.z)];
    float c010 = DensityPrev[int3(i0.x, i1.y, i0.z)];
    float c110 = DensityPrev[int3(i1.x, i1.y, i0.z)];
    float c001 = DensityPrev[int3(i0.x, i0.y, i1.z)];
    float c101 = DensityPrev[int3(i1.x, i0.y, i1.z)];
    float c011 = DensityPrev[int3(i0.x, i1.y, i1.z)];
    float c111 = DensityPrev[int3(i1.x, i1.y, i1.z)];
    
    // Trilinear interpolation
    float c00 = lerp(c000, c100, f.x);
    float c10 = lerp(c010, c110, f.x);
    float c01 = lerp(c001, c101, f.x);
    float c11 = lerp(c011, c111, f.x);
    
    float c0 = lerp(c00, c10, f.y);
    float c1 = lerp(c01, c11, f.y);
    
    return lerp(c0, c1, f.z);
}

// https://en.wikipedia.org/wiki/Trilinear_interpolation
float4 SampleVelocity(float3 pos)
{
    // Similar to SampleDensity but for float4
    pos = clamp(pos, float3(0, 0, 0), float3(_GridX - 1, _GridY - 1, _GridZ - 1));
    
    int3 i0 = int3(floor(pos));
    int3 i1 = min(i0 + 1, int3(_GridX - 1, _GridY - 1, _GridZ - 1));
    float3 f = frac(pos);
    
    float4 c000 = VelocityPrev[int3(i0.x, i0.y, i0.z)];
    float4 c100 = VelocityPrev[int3(i1.x, i0.y, i0.z)];
    float4 c010 = VelocityPrev[int3(i0.x, i1.y, i0.z)];
    float4 c110 = VelocityPrev[int3(i1.x, i1.y, i0.z)];
    float4 c001 = VelocityPrev[int3(i0.x, i0.y, i1.z)];
    float4 c101 = VelocityPrev[int3(i1.x, i0.y, i1.z)];
    float4 c011 = VelocityPrev[int3(i0.x, i1.y, i1.z)];
    float4 c111 = VelocityPrev[int3(i1.x, i1.y, i1.z)];
    
    float4 c00 = lerp(c000, c100, f.x);
    float4 c10 = lerp(c010, c110, f.x);
    float4 c01 = lerp(c001, c101, f.x);
    float4 c11 = lerp(c011, c111, f.x);
    
    float4 c0 = lerp(c00, c10, f.y);
    float4 c1 = lerp(c01, c11, f.y);
    
    return lerp(c0, c1, f.z);
}

// Stam's Semi-Lagrangian Advection: Pull particles backward
[numthreads(8,8,8)]
void Advect(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= (uint)_GridX || id.y >= (uint)_GridY || id.z >= (uint)_GridZ)
        return;
    
    // Semi-Lagrangian advection (Stam 1999)
    float3 pos = float3(id.xyz);
    float3 vel = VelocityPrev[id.xyz].xyz;
    
    // Trace particle backward in time
    float3 prevPos = pos - vel * _DeltaTime;
    
    // Sample previous values at traced position
    float newDensity = SampleDensity(prevPos);
    float4 newVelocity = SampleVelocity(prevPos);
    
    // Write advected values
    DensityNext[id.xyz] = newDensity;
    VelocityNext[id.xyz] = newVelocity;
}

// ============================================
// CURL NOISE - Add turbulence
// ============================================

// Simple 3D noise function (placeholder - replace with better noise)
float Noise3D(float3 p)
{
    return frac(sin(dot(p, float3(12.9898, 78.233, 45.164))) * 43758.5453);
}

// Compute curl of a potential field
float3 ComputeCurl(float3 pos, float epsilon)
{
    // Take three 3D noise fields
    float dx_p = Noise3D(pos + float3(epsilon, 0, 0));
    float dx_n = Noise3D(pos - float3(epsilon, 0, 0));
    
    float dy_p = Noise3D(pos + float3(0, epsilon, 0));
    float dy_n = Noise3D(pos - float3(0, epsilon, 0));
    
    float dz_p = Noise3D(pos + float3(0, 0, epsilon));
    float dz_n = Noise3D(pos - float3(0, 0, epsilon));
    
    
    // You can't compute ∂ψ/∂x for noise function so we approximate
    float dx = (dx_p - dx_n) / (2.0 * epsilon);
    float dy = (dy_p - dy_n) / (2.0 * epsilon);
    float dz = (dz_p - dz_n) / (2.0 * epsilon);
    
    // Curl = ∇ × ψ
    return float3(
        dz - dy,  // ∂ψ_z/∂y - ∂ψ_y/∂z
        dx - dz,  // ∂ψ_x/∂z - ∂ψ_z/∂x
        dy - dx   // ∂ψ_y/∂x - ∂ψ_x/∂y
    );
}

[numthreads(8,8,8)]
void CurlNoise(uint3 id : SV_DispatchThreadID)
{
    // Bounds
    if (id.x >= (uint)_GridX || id.y >= (uint)_GridY || id.z >= (uint)_GridZ)
        return;
    
    float3 pos = float3(id.xyz);
    
    // Compute curl noise
    float3 curl = ComputeCurl(pos * 0.1, 0.5); // Scale and epsilon
    
    // Add curl to velocity (scaled)
    float4 velocity = VelocityPrev[id.xyz];
    velocity.xyz += curl * 0.5; // Curl strength
    
    VelocityNext[id.xyz] = velocity;
    
    // Copy density unchanged
    DensityNext[id.xyz] = DensityPrev[id.xyz];
}

// Test
[numthreads(8,8,8)]
void FillTest(uint3 id : SV_DispatchThreadID)
{
    // Normalize coordinates 0..1
    float nx = id.x / (float)(_GridX - 1);
    float ny = id.y / (float)(_GridY - 1);
    float nz = id.z / (float)(_GridZ - 1);

    // Create a gradient cube to test
    DensityNext[id.xyz] = nx * ny * nz;
}
